#include "ClientMessages.h"
#include "ninjam/User.h"
#include <QCryptographicHash>
#include <QIODevice>
#include <QDebug>
#include <QDataStream>

using namespace Ninjam;

ClientMessage::ClientMessage(quint8 msgCode, quint32 payload)
    :msgType(msgCode), payload(payload){

}

ClientMessage::~ClientMessage()
{
}

void ClientMessage::serializeString(const QString &string, QDataStream &stream){
    //serializeByteArray(QByteArray(str.toStdString().c_str()), stream);

    //serializeByteArray(str.toUtf8(), stream);
    QByteArray dataArray = string.toUtf8();
    stream.writeRawData(dataArray.data(), dataArray.size());

    stream << quint8('\0'); // NUL TERMINATED
}

void ClientMessage::serializeByteArray(const QByteArray &array, QDataStream &stream){
    //qDebug() << "serializando " << array.size() << " bytes para " << array <<endl;
    for (int i = 0; i < array.size(); ++i) {
        stream << quint8(array[i]);
    }
}

//++++++++++++++++++++++++++++++++++++++=
//class ClientAuthUser
/*
     //message type 0x80

     Offset Type        Field
     0x0    uint8_t[20] Password Hash (binary hash value)
     0x14   ...         Username (NUL-terminated)
     x+0x0  uint32_t    Client Capabilities
     x+0x4  uint32_t    Client Version

     The Password Hash field is calculated by SHA1(SHA1(username + ":" + password) + challenge).
     If the user acknowledged a license agreement from the server then Client Capabilities bit 0 is set.
     The server responds with Server Auth Reply.

    //message lenght = 20 bytes password hash + user name lengh + 4 bytes client capabilites + 4 bytes client version
*/

ClientAuthUserMessage::ClientAuthUserMessage(const QString &userName, const QByteArray &challenge, quint32 protocolVersion, const QString &password)
    : ClientMessage(0x80, 0),
      userName(userName),
      clientCapabilites(1),
      protocolVersion(protocolVersion),
      challenge(challenge)
{
    if (!password.isNull() && !password.isEmpty()) {
        this->userName = userName;
    }
    else{
        this->userName = "anonymous:" + userName;
    }

    QCryptographicHash sha1(QCryptographicHash::Sha1);
    sha1.addData( userName.toStdString().c_str(), userName.size() );
    sha1.addData(":", 1);
    sha1.addData(password.toStdString().c_str(), password.size());
    QByteArray passHash = sha1.result();
    sha1.reset();
    sha1.addData(passHash);
    sha1.addData(challenge.constData(), 8);
    this->passwordHash = sha1.result();
    this->payload = 29 + this->userName.size();
}

void ClientAuthUserMessage::serializeTo(QByteArray& buffer) const {
    QDataStream stream(&buffer, QIODevice::WriteOnly);
    stream.setByteOrder(QDataStream::LittleEndian);
    stream << msgType << payload;
    serializeByteArray(passwordHash, stream);
    serializeString(userName, stream);
    stream << clientCapabilites;
    stream << protocolVersion;
}
//+++++++++++++++++++++++++++++++++++++++++++
void ClientAuthUserMessage::printDebug(QDebug &dbg) const
{
    dbg << "SEND ClientAuthUserMessage{  userName:" << userName << " challenge:" << challenge <<"}" << endl;
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ClientSetChannel::ClientSetChannel(const QStringList &channels)
    : ClientMessage(0x82, 0), volume(0), pan(0), flags(0)
{
    payload = 2;
    channelNames.append(channels);
    for (int i = 0; i < channelNames.size(); i++) {
        payload += (channelNames[i].size() + 1) + 2 + 1 + 1;//NUL + volume(short) + pan(byte) + flags(byte)
    }
}


ClientSetChannel::ClientSetChannel(const QString &channelNameToRemove)
    : ClientMessage(0x82, 0), volume(0), pan(0), flags(1)//to remove
{
    payload = 2;
    channelNames.append(channelNameToRemove);
    for (int i = 0; i < channelNames.size(); i++) {
        payload += (channelNames[i].size() + 1) + 2 + 1 + 1;//NUL + volume(short) + pan(byte) + flags(byte)
    }
}


void ClientSetChannel::serializeTo(QByteArray &buffer) const{
    QDataStream stream(&buffer, QIODevice::WriteOnly);
    stream.setByteOrder(QDataStream::LittleEndian);
    //payload = 0;
    stream << msgType << payload;
    //++++++++
    stream << quint16(4); //byteBuffer.putShort((short) 4);//parameter size (4 bytes - volume (2 bytes) + pan (1 byte) + flags (1 byte))
    for (int i = 0; i < channelNames.size(); ++i) {
        serializeString(channelNames[i], stream);// //byteBuffer.put(channelNames[i].getBytes("utf-8"));
        stream << volume;// byteBuffer.putShort(volume);
        stream << pan;//byteBuffer.put(pan);
        stream << flags;//byteBuffer.put(flags);
    }
}

void ClientSetChannel::printDebug(QDebug &dbg) const{
    dbg << "SEND ClientSetChannel{ payloadLenght=" << payload << " channelName=" << channelNames << '}' << endl;
}

//+++++++++++++++++++++
ClientKeepAlive::ClientKeepAlive()
    :ClientMessage(0xfd, 0)
{

}

void ClientKeepAlive::serializeTo(QByteArray &buffer) const{
    //just the header bytes, no payload
    QDataStream stream(&buffer, QIODevice::WriteOnly);
    stream.setByteOrder(QDataStream::LittleEndian);
    stream << msgType << payload;
}

void ClientKeepAlive::printDebug(QDebug &dbg) const{
    dbg << "SEND {Client KeepAlive}" << endl;
}
//+++++++++++++++++
ClientSetUserMask::ClientSetUserMask(const QList<QString> &users)
    :ClientMessage(0x81, 0)
{
    payload = 4 * users.size();//4 bytes (int) flag
    foreach (const QString &userFullName , users) {
        usersFullNames.append(userFullName);
        payload += userFullName.size() + 1;
    }
}

void ClientSetUserMask::serializeTo(QByteArray &buffer) const
{
    QDataStream stream(&buffer, QIODevice::WriteOnly);
    stream.setByteOrder(QDataStream::LittleEndian);
    stream << msgType;
    stream << payload;
    //++++++++++++  END HEADER ++++++++++++
    foreach (const QString &userName , usersFullNames) {
        ClientMessage::serializeString(userName, stream);
        stream << FLAG;
    }
}

void ClientSetUserMask::printDebug(QDebug &dbg) const
{
    dbg << "SEND ClientSetUserMask{ userNames=" << usersFullNames << " flag=" << FLAG << '}';
}

//+++++++++++++++++++++++++++++

ChatMessage::ChatMessage(const QString &text)
    : ClientMessage(0xc0, 0), text(text), command("MSG")
{
    payload = text.toUtf8().size() + 1 + command.length() + 1;
}

void ChatMessage::serializeTo(QByteArray &buffer) const{
    QDataStream stream(&buffer, QIODevice::WriteOnly);
    stream.setByteOrder(QDataStream::LittleEndian);
    stream << msgType;
    stream << payload;
    ClientMessage::serializeString(command, stream);
    ClientMessage::serializeString(text, stream);
}

void ChatMessage::printDebug(QDebug &dbg) const{
    dbg << "SEND ChatMessage{ payload: " << payload << " " << "command=" << command << " text=" << text << '}';
}

//+++++++++++++++++++++++++

ClientUploadIntervalBegin::ClientUploadIntervalBegin(const QByteArray &GUID, quint8 channelIndex, const QString &userName)
    :ClientMessage( 0x83, 16 + 4 + 4 + 1 + userName.size()),
      GUID(GUID),
      estimatedSize(0),
      //fourCC{'O', 'G', 'G', 'v'},
      channelIndex(channelIndex),
      userName(userName)
{
	fourCC[0] = 'O';
	fourCC[1] = 'G';
	fourCC[2] = 'G';
	fourCC[3] = 'v';
}

void ClientUploadIntervalBegin::serializeTo(QByteArray &buffer) const{
    QDataStream stream(&buffer, QIODevice::WriteOnly);
    stream.setByteOrder(QDataStream::LittleEndian);
    //quint32 payload = 16 + 4 + 4 + 1 + userName.size();
    stream << msgType;
    stream << payload;
    stream.writeRawData(GUID, 16);
    stream << estimatedSize;
    stream.writeRawData(fourCC, 4);
    stream << channelIndex;
    stream.writeRawData(userName.toStdString().c_str(), userName.size());

    if((quint32)buffer.size() != payload + 5){
        qCritical() << "wrong size!";
    }
}

void ClientUploadIntervalBegin::printDebug(QDebug &dbg) const{
    dbg << "SEND ClientUploadIntervalBegin{ GUID "  << QString(GUID) << " fourCC" << QString(fourCC) << "channelIndex: " << channelIndex << "userName:" << userName << "}";
}

//+++++++++++++++++++++
ClientIntervalUploadWrite::ClientIntervalUploadWrite(const QByteArray &GUID, const QByteArray &encodedAudioBuffer, bool isLastPart)
    :ClientMessage(0x84, 16 + 1 + encodedAudioBuffer.size()),
    GUID(GUID),
      encodedAudioBuffer(encodedAudioBuffer),
    isLastPart(isLastPart)
{

}

void ClientIntervalUploadWrite::serializeTo(QByteArray &buffer) const{
    QDataStream stream(&buffer, QIODevice::WriteOnly);
    stream.setByteOrder(QDataStream::LittleEndian);
    stream << msgType;
    stream << payload;

    stream.writeRawData(GUID.data(), 16);
    quint8 intervalCompleted = isLastPart ? (quint8) 1 : (quint8) 0;//If the Flag field bit 0 is set then the upload is complete.
    stream << intervalCompleted;
    stream.writeRawData( encodedAudioBuffer.data(), encodedAudioBuffer.size() );

    Q_ASSERT(buffer.size() == (int)(payload + 5));
}


 void ClientIntervalUploadWrite::printDebug(QDebug &dbg) const{
    dbg << "SEND ClientIntervalUploadWrite{" << "GUID=" << QString(GUID) << ", encodedAudioBuffer= " << payload << " bytes, isLastPart=" << isLastPart << '}';
}


//+++++++++++++++++++++++++++
QDebug& Ninjam::operator<<(QDebug &dbg, const ClientMessage &message)
{
    message.printDebug(dbg);
    return dbg;
}

QByteArray &Ninjam::operator <<(QByteArray &byteArray, const ClientMessage &message)
{
    message.serializeTo(byteArray);
    return byteArray;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
